<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Project Graph Viewer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --bg:#0f172a; --panel:#111827; --text:#e5e7eb; --muted:#9ca3af; }
    html,body { margin:0; height:100%; background:var(--bg); color:var(--text); font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,"Helvetica Neue",sans-serif; }
    .wrap { display:grid; grid-template-columns: 340px 1fr; height:100%; }
    .side { padding:16px; border-right:1px solid #1f2937; background: var(--panel); overflow:auto; }
    .main { position:relative; }
    #cy { position:absolute; inset:0; z-index:1; }

    /* overlay layer sits above graph; children control their own interactivity */
    #overlays {
      position:absolute; inset:0;
      z-index:3;               /* above #cy */
      pointer-events:none;     /* click-through by default */
    }
    /* wires ON TOP of popovers */
    #wires {
      position:absolute; inset:0;
      width:100%; height:100%;
      overflow:visible;
      z-index:5;               /* highest: always on top */
      pointer-events:none;     /* never block clicks */
    }
    /* popovers below wires but still clickable */
    .popover {
      position:absolute;
      z-index:4;               /* under wires, above cy */
      pointer-events:auto;     /* clickable */
      min-width: 260px;
      max-width: 460px;
      max-height: 260px;
      background:#0b1220;
      border:1px solid #334155;
      border-radius:10px;
      box-shadow: 0 10px 24px rgba(0,0,0,.45);
      overflow:hidden;
    }

    .h { font-weight:600; margin:0 0 8px; }
    .muted { color: var(--muted); }
    .box { background:#0b1220; border:1px solid #1f2937; border-radius:12px; padding:12px; margin:12px 0; }
    .row { display:flex; gap:8px; align-items:center; margin:8px 0; }
    .btn { cursor:pointer; background:#1e293b; border:1px solid #334155; color:#e2e8f0; padding:8px 12px; border-radius:10px; }
    .btn:hover { border-color:#475569; }
    input[type="file"] { width:100%; }
    input[type="text"] { width:100%; padding:8px 10px; border-radius:10px; border:1px solid #334155; background:#0b1220; color:#e5e7eb; }
    code { color:#eab308; }

    .popover .ph {
      display:flex; align-items:center; justify-content:space-between; gap:8px;
      background:#0f172a; border-bottom:1px solid #1f2937;
      padding:6px 8px;
    }
    .popover .title {
      font-weight:600; font-size:12px; color:#cbd5e1;
      overflow:hidden; text-overflow:ellipsis; white-space:nowrap; max-width:60ch;
    }
    .popover .actions { display:flex; gap:6px; }
    .popover .actions .btn { padding:4px 8px; font-size:12px; }
    .popover pre {
      margin:0; padding:10px; overflow:auto;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size:12px; white-space:pre-wrap; word-wrap:break-word;
      color:#e5e7eb;
    }

    /* function tokens (defs & calls) */
    .fn-hit { border-radius:4px; padding:0 2px; font-weight:600; }
    .fn-hit.hover { outline: 1px dashed #eab308; outline-offset: 2px; }

    /* SVG wires style */
    .wire { fill:none; stroke-width:2; stroke-opacity:.9; }
  </style>
  <!-- Cytoscape -->
  <script src="https://unpkg.com/cytoscape@3.28.1/dist/cytoscape.min.js"></script>
</head>
<body>
  <div class="wrap">
    <aside class="side">
      <h2 class="h">Project Graph</h2>
      <p class="muted">
        Upload a <code>.zip</code>. We build a <b>file-level</b> call graph.<br/>
        Click a node to open a popover with its code. Declarations & calls share a unique color.<br/>
        Foreground lines connect call sites ↔ their declarations between popovers.
      </p>

      <div class="box">
        <form id="zipForm">
          <div class="row"><input id="zipFile" type="file" name="file" accept=".zip" required></div>
          <div class="row">
            <button class="btn" type="submit">Build graph</button>
            <button class="btn" type="button" id="resetBtn">Reset</button>
          </div>
        </form>
        <div id="status" class="muted"></div>
      </div>

      <div class="box">
        <h3 class="h">Metrics</h3>
        <div id="metrics" class="muted">—</div>
      </div>

      <div class="box">
        <h3 class="h">Filters</h3>
        <div class="row"><input id="fileFilter" type="text" placeholder="Filter by filename substring…"></div>
        <div class="row"><input id="nodeQuery" type="text" placeholder="Find node (label)…"></div>
        <div class="row">
          <button class="btn" id="applyFilter" type="button">Apply</button>
          <button class="btn" id="clearFilter" type="button">Clear</button>
        </div>
      </div>
    </aside>

    <main class="main">
      <div id="cy"></div>
      <div id="overlays">
        <svg id="wires"></svg>
      </div>
    </main>
  </div>

<script>
  // Use 8000 if serving static via 5500; otherwise same-origin
  const API_BASE = (location.port === '5500') ? 'http://127.0.0.1:8000' : '';

  // Globals
  let cyGraph = null;
  let graphSources = {};              // { filePath: content }
  const popOwner = new Map();         // popoverEl -> nodeId  (multiple per node allowed)

  // Function coloring/defs
  let fnColors = new Map();           // functionName -> color
  let namesByFile = new Map();        // filePath -> Set(functionNamesSeenInFile)
  let defsByFile = new Map();         // filePath -> Set(functionNamesDeclaredHere)

  // Colors
  const HUES = [0,30,55,85,120,165,200,230,260,290,320];
  const MATCH_COLORS = HUES.map(h => `hsl(${h} 80% 55%)`);
  const colorFor = (()=>{ const m=new Map(); let i=0; return k => m.has(k)?m.get(k):(m.set(k,MATCH_COLORS[i++%MATCH_COLORS.length]), m.get(k)); })();

  // Normalize server response
  function normalizeToGraph(payload){
    if (!payload) return {global:{}, files:{}, sources:{}};
    if (payload.global && payload.files) return { global:payload.global, files:payload.files, sources:payload.sources || {} };
    if (payload.result) return { global:payload.result.global||{}, files:payload.result.files||{}, sources:payload.result.sources||{} };
    return { global:payload.global||{}, files:payload.files||{}, sources:payload.sources||{} };
  }

  // Extract for metrics and edges
  function extractDefinitions(globalResults){
    const defs = [];
    const list = Array.isArray(globalResults?.defined) ? globalResults.defined : [];
    for (const d of list){
      const name = d?.name || d?.function || d?.id || 'anon';
      const file = d?.file || d?.path || d?.module || 'unknown';
      defs.push({ name, file });
    }
    return defs;
  }
  function extractCalls(globalResults, fileResults){
    const calls = [];
    const gCalled = globalResults?.called;
    if (gCalled && typeof gCalled === 'object'){
      Object.entries(gCalled).forEach(([callee, sites])=>{
        (sites||[]).forEach(s => calls.push({ name: callee, file: s?.file || s?.path || 'unknown' }));
      });
    }
    const candidateKeys = ["python","python_relations","js","js_relations","c","c_relations"];
    Object.entries(fileResults || {}).forEach(([fname, rel])=>{
      if (!rel || typeof rel !== 'object') return;
      const buckets = candidateKeys.map(k=>rel[k]).filter(Boolean).concat([rel]);
      for (const b of buckets){
        if (Array.isArray(b?.calls)){
          b.calls.forEach(c => calls.push({ name: c?.name || c?.function || c?.callee || 'unknown', file: fname }));
        } else if (b?.called && typeof b.called === 'object'){
          Object.entries(b.called).forEach(([callee, sites])=>{
            (sites||[]).forEach(() => calls.push({ name: callee, file: fname }));
          });
        }
      }
    });
    return calls;
  }

  // Function color map & names per file
  function buildFunctionColorMap(globalResults, fileResults){
    const names = new Set();

    (Array.isArray(globalResults?.defined) ? globalResults.defined : []).forEach(d=>{
      const n = d?.name || d?.function || d?.id; if(n) names.add(n);
    });

    const gCalled = globalResults?.called;
    if (gCalled && typeof gCalled === 'object'){
      Object.keys(gCalled).forEach(n => names.add(n));
    }

    const candidateKeys = ["python","python_relations","js","js_relations","c","c_relations"];
    Object.values(fileResults || {}).forEach(rel=>{
      if (!rel || typeof rel !== 'object') return;
      const buckets = candidateKeys.map(k=>rel[k]).filter(Boolean).concat([rel]);
      for (const b of buckets){
        if (Array.isArray(b?.calls)){
          b.calls.forEach(c => { const n = c?.name || c?.function || c?.callee; if(n) names.add(n); });
        } else if (b?.called && typeof b.called === 'object'){
          Object.keys(b.called).forEach(n => names.add(n));
        }
      }
    });

    const out = new Map();
    let i=0;
    [...names].sort((a,b)=>b.length-a.length).forEach(n=>{
      out.set(n, MATCH_COLORS[i++ % MATCH_COLORS.length]);
    });
    return out;
  }
  function buildNamesByFile(globalResults, fileResults){
    const map = new Map();

    (Array.isArray(globalResults?.defined) ? globalResults.defined : []).forEach(d=>{
      const file = d?.file || d?.path || d?.module; const n = d?.name || d?.function || d?.id;
      if(file && n){ if(!map.has(file)) map.set(file, new Set()); map.get(file).add(n); }
    });

    const candidateKeys = ["python","python_relations","js","js_relations","c","c_relations"];
    Object.entries(fileResults || {}).forEach(([fname, rel])=>{
      if(!map.has(fname)) map.set(fname, new Set());
      if (!rel || typeof rel !== 'object') return;
      const bucketList = candidateKeys.map(k=>rel[k]).filter(Boolean).concat([rel]);
      for (const b of bucketList){
        if (Array.isArray(b?.calls)){
          b.calls.forEach(c=>{ const n = c?.name || c?.function || c?.callee; if(n) map.get(fname).add(n); });
        } else if (b?.called && typeof b.called === 'object'){
          Object.keys(b.called).forEach(n => map.get(fname).add(n));
        }
      }
    });

    return map;
  }
  function buildDefsByFile(globalResults){
    const map = new Map();
    (Array.isArray(globalResults?.defined) ? globalResults.defined : []).forEach(d=>{
      const file = d?.file || d?.path || d?.module; const n = d?.name || d?.function || d?.id;
      if(file && n){ if(!map.has(file)) map.set(file, new Set()); map.get(file).add(n); }
    });
    return map;
  }

  // Build FILE graph
  function buildFileGraphElements(globalResults, fileResults, sources){
    const defs = extractDefinitions(globalResults);
    const calls = extractCalls(globalResults, fileResults);
    const defFilesByName = new Map(); // callee -> Set(files where defined)
    defs.forEach(d => { const set = defFilesByName.get(d.name) || new Set(); set.add(d.file); defFilesByName.set(d.name, set); });

    const fileSet = new Set([
      ...Object.keys(fileResults || {}),
      ...defs.map(d => d.file),
      ...calls.map(c => c.file),
      ...Object.keys(sources || {})
    ]);

    // Nodes: one per file
    const nodes = [...fileSet].map(file => ({
      group: 'nodes',
      data: { id:`file|${file}`, label:(file||'unknown').split('/').slice(-1)[0], file }
    }));

    // Edges: A -> B if A calls something defined in B (cross-file)
    const edgeMap = new Map(); // "A||B" -> { count, callees:Set }
    for (const c of calls){
      const src = c.file;
      const targets = defFilesByName.get(c.name);
      if (!targets) continue;
      targets.forEach(dst => {
        if (src === dst) return;
        const key = `${src}||${dst}`;
        let entry = edgeMap.get(key);
        if (!entry) { entry = { count:0, callees:new Set() }; edgeMap.set(key, entry); }
        entry.count += 1; entry.callees.add(c.name);
      });
    }

    const edges = [];
    for (const [key, entry] of edgeMap.entries()){
      const [src, dst] = key.split('||');
      const color = colorFor(key);
      edges.push({
        group:'edges',
        data:{
          id:`e|${src}|${dst}`,
          source:`file|${src}`,
          target:`file|${dst}`,
          weight:entry.count,
          label:`${entry.count}`,
          tip:[...entry.callees].slice(0,6).join(', ')+(entry.callees.size>6?'…':''),
          color
        }
      });
    }
    return { elements:[...nodes, ...edges] };
  }

  // Render + interactions
  function renderFileGraph(globalResults, fileResults, sources){
    const { elements } = buildFileGraphElements(globalResults, fileResults, sources);

    const style = [
      { selector:'node',
        style:{
          'background-color':'#0ea5e9',
          'label':'data(label)',
          'color':'#e5e7eb',
          'font-size':12,
          'text-wrap':'wrap',
          'text-max-width':240,
          'border-width':1,
          'border-color':'#334155',
          'padding':'6px',
          'shape':'round-rectangle'
        }
      },
      { selector:'edge',
        style:{
          'curve-style':'bezier',
          'width': ele => Math.min(8, 1 + (parseInt(ele.data('weight')||1, 10) * 0.8)),
          'line-color':'data(color)',
          'target-arrow-shape':'triangle',
          'target-arrow-color':'data(color)',
          'label':'data(label)',
          'font-size':9,
          'color':'#cbd5e1',
          'text-background-opacity':0.15,
          'text-background-color':'#0b1220',
          'text-background-shape':'round-rectangle',
          'text-background-padding':2
        }
      },
      { selector:':selected', style:{ 'border-width':3, 'border-color':'#f59e0b' } }
    ];

    const container = document.getElementById('cy');
    if (!container) throw new Error('#cy not found');

    if (cyGraph && typeof cyGraph.destroy === 'function'){ try { cyGraph.destroy(); } catch {} }
    clearAllPopovers();
    clearWires();

    cyGraph = cytoscape({ container, elements, style, layout:{ name:'cose', animate:false, padding:24 } });
    cyGraph.resize();

    // click node -> open popover at node
    cyGraph.off('tap', 'node');
    cyGraph.on('tap', 'node', evt => openCodePopover(evt.target));

    // keep popovers & wires glued to nodes during interactions
    const repositionAll = () => {
      popOwner.forEach((nodeId, el) => {
        const n = cyGraph.getElementById(nodeId);
        if (n && n.nonempty()) positionPopover(el, n);
      });
      redrawWires();
    };
    cyGraph.on('pan zoom render', repositionAll);
    cyGraph.on('drag position', 'node', evt => {
      popOwner.forEach((nid, el) => { if (nid === evt.target.id()) positionPopover(el, evt.target); });
      redrawWires();
    });
    cyGraph.on('layoutstop', repositionAll);

    // ensure wires are above all overlays children
    bringWiresToFront();
  }

  // ---------- popover & code helpers ----------
  function normPath(p){ return (p||'').replace(/\\/g,'/').replace(/^\.\/+/,'').replace(/\/+/g,'/'); }
  function commonSuffixLen(a,b){ let i=0; for(let ai=a.length-1,bi=b.length-1; ai>=0&&bi>=0; ai--,bi--){ if(a[ai]!==b[bi]) break; i++; } return i; }
  function bestSourceFor(file, sourcesMap){
    if (!file || !sourcesMap) return '';
    const req = normPath(file);
    if (req in sourcesMap) return sourcesMap[req];
    const reqBase = req.split('/').pop();
    let bestKey=null, bestScore=-1;
    for (const k of Object.keys(sourcesMap)){
      const nk = normPath(k);
      if (nk === req) return sourcesMap[k];
      if (nk.split('/').pop() === reqBase){
        const s = commonSuffixLen(nk, req);
        if (s > bestScore){ bestScore = s; bestKey = k; }
      }
    }
    if (!bestKey){
      for (const k of Object.keys(sourcesMap)){
        const s = commonSuffixLen(normPath(k), req);
        if (s > bestScore){ bestScore = s; bestKey = k; }
      }
    }
    return bestKey ? sourcesMap[bestKey] : '';
  }
  function escapeHtml(s){ return (s||'').replace(/[&<>"']/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }

  // colorize declared & called functions (shared colors across project)
  function highlightCode(rawText, namesSet, fnColorMap){
    if (!rawText) return '';
    let html = escapeHtml(rawText);

    const names = Array.from(namesSet || []);
    if (!names.length) return html;

    const esc = s => s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    const group = names.sort((a,b)=>b.length-a.length).map(esc).join('|');
    // match NAME( with optional spaces, word boundary
    const re = new RegExp(`\\b(${group})\\s*\\(`, 'g');

    html = html.replace(re, (m, name) => {
      const col = fnColorMap.get(name) || '#eab308';
      const bg  = /^hsl\(/i.test(col) ? col.replace(/\)$/, ' / 0.18)') : 'rgba(234,179,8,0.18)';
      return `<span class="fn-hit" data-fn="${name}" style="color:${col}; background:${bg};">${name}</span>(`;
    });

    return html;
  }

  function openCodePopover(node){
    const file = node.data('file');
    const content = bestSourceFor(file, graphSources) || '';

    // names to highlight in THIS file
    const names = namesByFile.get(file) || new Set();

    const pop = document.createElement('div');
    pop.className = 'popover';
    pop.innerHTML = `
      <div class="ph">
        <div class="title" title="${file || ''}">${file || '(unknown file)'}</div>
        <div class="actions">
          <button class="btn" data-act="copy">Copy</button>
          <button class="btn" data-act="dl">Download</button>
          <button class="btn" data-act="x">Close</button>
        </div>
      </div>
      <pre></pre>
    `;

    const pre = pop.querySelector('pre');
    pre.innerHTML = highlightCode(content, names, fnColors) || '(no source available)';

    // mark decl vs call using defsByFile
    const defSet = defsByFile.get(file) || new Set();
    pre.querySelectorAll('.fn-hit').forEach(el=>{
      const n = el.dataset.fn;
      const role = defSet.has(n) ? 'decl' : 'call';
      el.dataset.role = role;
      if (role === 'decl') el.style.boxShadow = 'inset 0 -1px 0 rgba(255,255,255,.25)';
    });

    // actions
    pop.querySelector('[data-act="x"]').onclick = () => { unlinkPopover(pop); pop.remove(); redrawWires(); };
    pop.querySelector('[data-act="copy"]').onclick = async () => { try { await navigator.clipboard.writeText(content); } catch {} };
    pop.querySelector('[data-act="dl"]').onclick = () => {
      const blob = new Blob([content], { type:'text/plain;charset=utf-8' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = (file || 'source.txt').split('/').pop() || 'source.txt';
      document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(a.href);
    };

    // hover highlight sync with wires
    pre.addEventListener('mouseover', (e)=>{
      const t = e.target.closest('.fn-hit');
      if (!t) return;
      const fn = t.dataset.fn;
      document.querySelectorAll(`.fn-hit[data-fn="${CSS.escape(fn)}"]`).forEach(x=>x.classList.add('hover'));
      document.querySelectorAll(`.wire[data-fn="${CSS.escape(fn)}"]`).forEach(w=>{ w.style.strokeWidth = '3.5'; w.style.strokeOpacity = '1'; });
    });
    pre.addEventListener('mouseout', (e)=>{
      const t = e.target.closest('.fn-hit');
      if (!t) return;
      const fn = t.dataset.fn;
      document.querySelectorAll(`.fn-hit[data-fn="${CSS.escape(fn)}"]`).forEach(x=>x.classList.remove('hover'));
      document.querySelectorAll(`.wire[data-fn="${CSS.escape(fn)}"]`).forEach(w=>{ w.style.strokeWidth = '2'; w.style.strokeOpacity = '.9'; });
    });

    // scroll inside popover -> wire endpoints move
    pre.addEventListener('scroll', () => { redrawWires(); }, { passive:true });

    document.getElementById('overlays').appendChild(pop);
    linkPopover(pop, node);
    positionPopover(pop, node, { dx: 14, dy: -14 });

    // ensure wires stay on top after adding popover
    bringWiresToFront();
    redrawWires();
  }

  function linkPopover(pop, node){ popOwner.set(pop, node.id()); }
  function unlinkPopover(pop){ popOwner.delete(pop); }
  function clearAllPopovers(){ document.querySelectorAll('#overlays .popover').forEach(el => el.remove()); popOwner.clear(); }
  function positionPopover(pop, node, offset={dx:12, dy:-12}){
    if (!pop || !node) return;
    const pos = node.renderedPosition();
    pop.style.left = `${pos.x + offset.dx}px`;
    pop.style.top  = `${pos.y + offset.dy}px`;
  }

  // ---------- WIRES (call ↔ decl between popovers) ----------
  function bringWiresToFront(){
    const overlays = document.getElementById('overlays');
    const wires = document.getElementById('wires');
    if (overlays && wires && wires.parentNode === overlays) overlays.appendChild(wires); // move to end
  }
  function clearWires(){
    const svg = document.getElementById('wires');
    while (svg.firstChild) svg.removeChild(svg.firstChild);
  }

  function redrawWires(){
    const svg = document.getElementById('wires');
    if (!svg) return;
    clearWires();

    const overlayRect = document.getElementById('overlays').getBoundingClientRect();

    // collect tokens grouped by function and role
    const allPops = Array.from(document.querySelectorAll('#overlays .popover'));
    const declMap = new Map(); // fn -> [el]
    const callMap = new Map(); // fn -> [el]

    allPops.forEach(pop=>{
      pop.querySelectorAll('.fn-hit').forEach(tok=>{
        const fn = tok.dataset.fn;
        const role = tok.dataset.role || 'call';
        if (!fn) return;
        const map = (role === 'decl') ? declMap : callMap;
        if (!map.has(fn)) map.set(fn, []);
        map.get(fn).push(tok);
      });
    });

    // For each call token, connect to first decl token across all open popovers
    callMap.forEach((callEls, fn) => {
      const declEls = declMap.get(fn) || [];
      if (!declEls.length) return; // nothing to connect to

      const decl = declEls[0];
      const dRect = decl.getBoundingClientRect();
      const dPt = {
        x: (dRect.left + dRect.right)/2 - overlayRect.left,
        y: (dRect.top + dRect.bottom)/2 - overlayRect.top
      };

      callEls.forEach(cEl => {
        const cRect = cEl.getBoundingClientRect();
        const cPt = {
          x: (cRect.left + cRect.right)/2 - overlayRect.left,
          y: (cRect.top + cRect.bottom)/2 - overlayRect.top
        };

        const col = fnColors.get(fn) || '#60a5fa';

        // cubic bezier from call -> decl
        const dx = (dPt.x - cPt.x);
        const mx = cPt.x + dx * 0.5;
        const d = `M ${cPt.x.toFixed(1)} ${cPt.y.toFixed(1)} C ${mx.toFixed(1)} ${cPt.y.toFixed(1)}, ${mx.toFixed(1)} ${dPt.y.toFixed(1)}, ${dPt.x.toFixed(1)} ${dPt.y.toFixed(1)}`;

        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('class', 'wire');
        path.setAttribute('data-fn', fn);
        path.setAttribute('d', d);
        path.setAttribute('stroke', col);
        svg.appendChild(path);
      });
    });

    // keep wires on top after drawing
    bringWiresToFront();
  }

  // Filters
  function applyFilters(){
    if (!cyGraph) return;
    const fileSub = (document.getElementById('fileFilter').value || '').toLowerCase().trim();
    const nodeQ   = (document.getElementById('nodeQuery').value || '').toLowerCase().trim();
    cyGraph.batch(()=>{
      cyGraph.elements().style('display','element');
      if (fileSub){
        cyGraph.nodes().forEach(n=>{
          const f = (n.data('file')||'').toLowerCase();
          if (!f.includes(fileSub)) n.style('display','none');
        });
      }
      if (nodeQ){
        cyGraph.nodes().forEach(n=>{
          const lbl = (n.data('label')||'').toLowerCase();
          if (!lbl.includes(nodeQ)) n.style('display','none');
        });
      }
      cyGraph.edges().forEach(e=>{
        const s = e.source().style('display') !== 'none';
        const t = e.target().style('display') !== 'none';
        if (!(s && t)) e.style('display','none');
      });
    });
  }
  function clearFilters(){
    document.getElementById('fileFilter').value = '';
    document.getElementById('nodeQuery').value = '';
    cyGraph?.elements().style('display','element');
  }

  // Boot
  document.addEventListener('DOMContentLoaded', () => {
    const elStatus = document.getElementById('status');
    const elZip = document.getElementById('zipFile');
    const elForm = document.getElementById('zipForm');
    function setStatus(msg){ elStatus.textContent = msg || ''; }

    elForm.addEventListener('submit', async (e) => {
      e.preventDefault();
      if (!elZip.files.length) return;
      setStatus('Uploading & parsing…');

      try {
        const fd = new FormData();
        fd.append('file', elZip.files[0]);

        const res = await fetch(`${API_BASE}/api/code/parse-zip/`, { method:'POST', body: fd });
        const raw = await res.text();
        if (!res.ok){ console.error('API error body:', raw); setStatus('Error: ' + res.status); return; }

        let payload; try { payload = JSON.parse(raw); } catch(e){ console.error('JSON parse error:', e, raw); setStatus('Bad JSON from API'); return; }
        const { global, files, sources } = normalizeToGraph(payload);
        graphSources = sources || {};

        // build color map, names per file, and defs per file
        fnColors = buildFunctionColorMap(global, files);
        namesByFile = buildNamesByFile(global, files);
        defsByFile = buildDefsByFile(global);

        // metrics
        const filesCount = Object.keys(files||{}).length || Object.keys(graphSources||{}).length;
        const defsCount  = Array.isArray(global?.defined) ? global.defined.length : 0;
        const callsCount = Object.values(global?.metrics || {}).reduce((a,m)=>a + ((m||{}).num_calls||0), 0);
        document.getElementById('metrics').textContent = `files: ${filesCount} • definitions: ${defsCount} • calls: ${callsCount}`;

        renderFileGraph(global, files, graphSources);
        setStatus('Done.');
      } catch (err) {
        console.error(err);
        setStatus('Request failed.');
      }
    });

    document.getElementById('resetBtn').addEventListener('click', ()=>{
      cyGraph?.destroy(); cyGraph = null;
      clearAllPopovers();
      clearWires();
      document.getElementById('metrics').textContent = '—';
      document.getElementById('status').textContent = '';
    });
    document.getElementById('applyFilter').addEventListener('click', applyFilters);
    document.getElementById('clearFilter').addEventListener('click', clearFilters);

    // keep wires aligned on window resize
    window.addEventListener('resize', () => redrawWires());
  });
</script>
</body>
</html>
